// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © mrussel
//@version=5
strategy("4H Sweep + Strong Close (ATR Distance Filter)", overlay=true, pyramiding=0, process_orders_on_close=false, calc_on_order_fills=true, initial_capital=10000)

// --------------------
// Inputs
// --------------------
smalen = input.int(35, "SMA Length", minval=1)
atrlen = input.int(5, "ATR Length", minval=1)

stageAtrMult = input.float(5.0, "Stage: max distance (ATR multiples)", minval=0.0)
strongClosePct = input.float(0.65, "Strong close threshold", minval=0.0, maxval=1.0, tooltip="Bullish: (close-low)/(high-low) >= threshold. Bearish: (high-close)/(high-low) >= threshold.")

enableLong = input.bool(true, "Enable longs")
enableShort = input.bool(true, "Enable shorts")

tpR = input.float(1.2, "Take Profit (R multiple)", minval=0.0, tooltip="TP = entry +/- (R multiple)*R, where R = |entry - stop|")
moveStopToBEAt1R = input.bool(true, "Move stop to breakeven after 1R")

avoidLateCandles = input.bool(false, "Avoid late 4H candles (13:00-17:00 & 17:00-21:00)")
sessionTz = input.string("Exchange", "Timezone for late-candle filter", tooltip="Use 'Exchange' to use the symbol's exchange timezone. Defaults must be constant strings.")
avoidStart1 = input.int(13, "Avoid window 1 start hour", minval=0, maxval=23)
avoidEnd1 = input.int(17, "Avoid window 1 end hour", minval=0, maxval=24)
avoidStart2 = input.int(17, "Avoid window 2 start hour", minval=0, maxval=23)
avoidEnd2 = input.int(21, "Avoid window 2 end hour", minval=0, maxval=24)

enforce4h = input.bool(false, "Enforce 4H timeframe only")

// --------------------
// Indicators
// --------------------
sma35 = ta.sma(close, smalen)
atr5 = ta.atr(atrlen)

// --------------------
// Rules
// --------------------
is4h = timeframe.period == "240"
allowedTf = not enforce4h or is4h

barHour = hour(time, sessionTz)
inAvoidWindow1 = barHour >= avoidStart1 and barHour < avoidEnd1
inAvoidWindow2 = barHour >= avoidStart2 and barHour < avoidEnd2
allowedTime = not avoidLateCandles or not (inAvoidWindow1 or inAvoidWindow2)

bullish = close > sma35
bearish = close < sma35

stageBull = not na(atr5) and atr5 != 0.0 and math.abs(low - sma35) <= stageAtrMult * atr5
stageBear = not na(atr5) and atr5 != 0.0 and math.abs(high - sma35) <= stageAtrMult * atr5

sweepLow = low < low[1]
sweepHigh = high > high[1]

rng = high - low
strongCloseBull = rng > 0 ? ((close - low) / rng) >= strongClosePct : false
strongCloseBear = rng > 0 ? ((high - close) / rng) >= strongClosePct : false

longSignal = enableLong and allowedTf and allowedTime and bullish and stageBull and sweepLow and strongCloseBull
shortSignal = enableShort and allowedTf and allowedTime and bearish and stageBear and sweepHigh and strongCloseBear

// --------------------
// Entry (fills next bar open in backtest)
// Also latch the signal candle stop level so SL is signal candle Low/High.
// --------------------
var float pendingStopBase = na
var int pendingDir = 0 // 1=long, -1=short

if barstate.isconfirmed and strategy.position_size == 0
    if longSignal
        pendingDir := 1
        pendingStopBase := low
        strategy.entry("L", strategy.long)
    else if shortSignal
        pendingDir := -1
        pendingStopBase := high
        strategy.entry("S", strategy.short)

// --------------------
// Risk management
// - Stop Loss at signal candle Low/High
// - TP at 1.2R
// - Move stop to breakeven once 1R is touched
// --------------------
var float tradeStopBase = na
var int tradeDir = 0
var bool movedToBE = false

newLong = strategy.position_size > 0 and strategy.position_size[1] == 0
newShort = strategy.position_size < 0 and strategy.position_size[1] == 0
flatNow = strategy.position_size == 0

if flatNow and strategy.position_size[1] != 0
    tradeStopBase := na
    tradeDir := 0
    movedToBE := false

if newLong
    tradeDir := 1
    tradeStopBase := pendingStopBase
    movedToBE := false
    pendingStopBase := na
    pendingDir := 0

if newShort
    tradeDir := -1
    tradeStopBase := pendingStopBase
    movedToBE := false
    pendingStopBase := na
    pendingDir := 0

if strategy.position_size != 0 and not na(tradeStopBase)
    entry = strategy.position_avg_price
    r = tradeDir == 1 ? (entry - tradeStopBase) : (tradeStopBase - entry)
    validR = r > 0

    touched1R = validR and (
         (tradeDir == 1 and high >= entry + r) or
         (tradeDir == -1 and low <= entry - r)
     )

    if moveStopToBEAt1R and touched1R
        movedToBE := true

    stopToUse = validR ? (movedToBE ? entry : tradeStopBase) : na
    limitToUse = validR ? (tradeDir == 1 ? entry + tpR * r : entry - tpR * r) : na

    if tradeDir == 1
        strategy.exit("L-X", from_entry="L", stop=stopToUse, limit=limitToUse)
    else if tradeDir == -1
        strategy.exit("S-X", from_entry="S", stop=stopToUse, limit=limitToUse)

// --------------------
// Visuals
// --------------------
plot(sma35, "SMA 35", color=color.yellow)
plotshape(longSignal, title="Long signal", style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny, text="L")
plotshape(shortSignal, title="Short signal", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.tiny, text="S")

var label tfWarn = na
if barstate.islast
    if not na(tfWarn)
        label.delete(tfWarn)
    if timeframe.period != "240"
        tfWarn := label.new(bar_index, high, "Designed for 4H (240). Current: " + timeframe.period, style=label.style_label_down, textcolor=color.white, color=color.new(color.orange, 0))
